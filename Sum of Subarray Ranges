Problem Number: 2104
Problem Name: Sum of Subarray Ranges
Link: https://leetcode.com/problems/sum-of-subarray-ranges/

Question
You are given an integer array nums. The range of a subarray of nums is the difference between the largest and smallest element in the subarray.
Return the sum of all subarray ranges of nums.
A subarray is a contiguous non-empty sequence of elements within an array.


Editorial Link: 1. https://leetcode.com/problems/sum-of-subarray-ranges/discuss/1624222/JavaC%2B%2BPython-O(n)-solution-detailed-explanation
                2. https://leetcode.com/problems/sum-of-subarray-ranges/discuss/1626628/O(n)-solution-with-monotonous-stack-oror-Full-explaination
                3. https://leetcode.com/problems/sum-of-subarray-ranges/discuss/1696344/Java-or-Well-explained-with-examples-or-O(n)
                4. https://leetcode.com/problems/sum-of-subarray-ranges/discuss/1673144/C%2B%2B-Solution-or-O(n2)-to-O(n)-or-Detailed-explanation-with-Walkthrough-of-Tricky-Test-Cases


Solution

APPROACH 1
Time Complexity: O(N * N), where N is the length of string
Space Complexity: O(1)


class Solution {
    public long subArrayRanges(int[] nums) {
        
        int n = nums.length;
        long ans = 0;
        for(int i=0; i<n; i++){
            long min = nums[i];
            long max = nums[i];
            
            for(int j=i; j<n; j++){
                
                min = Math.min(min, nums[j]);
                max = Math.max(max, nums[j]);
                
                ans += (max - min);
            }
        }
        
        return ans;
    }
}
 
 
 
APPROACH 2
Time Complexity: O(N), where N is the length of string
Space Complexity: O(N), where N is the length of string


class Solution {
    
    public void findPrevSmallestNumber(int[] arr, long[] prevSmallestElement){
        int n = arr.length;
        
        Stack<Integer> st1 = new Stack<>();
        for(int i=0; i<n; i++){
           
            while(st1.size() > 0  &&  arr[st1.peek()] >= arr[i]){
                st1.pop();
            }
                
            if(st1.size() == 0){
                prevSmallestElement[i] = i;
            }
            else{
                prevSmallestElement[i] = i - st1.peek() - 1;
            }
            
            st1.push(i);        
        }  
    }
    
    public void findNextSmallestNumber(int[] arr, long[] nextSmallestElement){
        int n = arr.length;
        
        Stack<Integer> st1 = new Stack<>();
        for(int i=n-1; i>=0; i--){
                        
            while(st1.size() > 0  &&  arr[st1.peek()] > arr[i]){
                st1.pop();
            }
                
            if(st1.size() == 0){
                nextSmallestElement[i] = n - 1 - i;
            }
            else{
                nextSmallestElement[i] = st1.peek() - i - 1;
            }
            
            st1.push(i);        
        }  
    }
    
    public void findPrevBiggestNumber(int[] arr, long[] prevBiggestElement){
        int n = arr.length;
        
        Stack<Integer> st1 = new Stack<>();
        for(int i=0; i<n; i++){
           
            while(st1.size() > 0  &&  arr[st1.peek()] <= arr[i]){
                st1.pop();
            }
                
            if(st1.size() == 0){
                prevBiggestElement[i] = i;
            }
            else{
                prevBiggestElement[i] = i - st1.peek() - 1;
            }
            
            st1.push(i);        
        }  
    }
    
    public void findNextBiggestNumber(int[] arr, long[] nextBiggestElement){
        int n = arr.length;
        
        Stack<Integer> st1 = new Stack<>();
        for(int i=n-1; i>=0; i--){
                        
            while(st1.size() > 0  &&  arr[st1.peek()] < arr[i]){
                st1.pop();
            }
                
            if(st1.size() == 0){
                nextBiggestElement[i] = n - 1 - i;
            }
            else{
                nextBiggestElement[i] = st1.peek() - i - 1;
            }
            
            st1.push(i);        
        }  
    }
    
    public long subArrayRanges(int[] arr) {
        
        int n = arr.length;
        
        long[] prevSmallestElement = new long[n];
        findPrevSmallestNumber(arr, prevSmallestElement);
        
        long[] nextSmallestElement = new long[n];
        findNextSmallestNumber(arr, nextSmallestElement);
        
        long[] prevBiggestElement = new long[n];
        findPrevBiggestNumber(arr, prevBiggestElement);
        
        long[] nextBiggestElement = new long[n];
        findNextBiggestNumber(arr, nextBiggestElement);
        
        long ans = 0;
        for(int i=0; i<n; i++){
            
            /*
                sum = sum(max) - sum(min)
                
                sum(max) = (number of subarrays where a[i] is maximum) * a[i]
                sum(min) = (number of subarrays where a[i] is minimum) * a[i]                             
            */

            long current1 = ((prevSmallestElement[i] + 1) * (nextSmallestElement[i] + 1));
            long current2 = ((prevBiggestElement[i] + 1) * (nextBiggestElement[i] + 1));
            
            ans += (arr[i] * (current2 - current1));
        }
        
        return ans;
    }
}

        
/*  here while finding next/ prev smallest number or next/ prev biggest number, in one we used "equal to" sign and in other we didn't use equality sign. As there will be 
    duplicate elements using equality sign on both places, we will add few subarrays more than once. Also, we can see this through an example.    
*/

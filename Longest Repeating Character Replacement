Problem Number: 424
Problem Name: Longest Repeating Character Replacement
Link: https://leetcode.com/problems/longest-repeating-character-replacement/

Question
You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.
Return the length of the longest substring containing the same letter you can get after performing the above operations.
 
           
            
Solution 


Time Complexity: O(26 * N), where N is the length of the array
Space Complexity: O(1), where N is the length of the array


APPROACH 1
class Solution {
    public int characterReplacement(String s, int k) {
        
        int ans = 0;
        int n = s.length();
        
        // Iterating through each character to find ans when they are considered as the most frequent character
        for(char ch = 'A'; ch <= 'Z'; ch++) {
            
            int left=0, right=0;
            int replacementCharacterCount = 0;   // stores number of characters to be replaced in a string
            
            // Iterate over the while string to find the longest string
            while (right < n) {
                
                // If right pointer finds matching character, then we can move right pointer ahead
                if (s.charAt(right) == ch) {
                    right++;
                }
                else {
                    
                    // If right pointer doesn't find matching character and the replacementCharacterCount is less than 'K', then we can move right pointer ahead as still the condition will pass
                    if (replacementCharacterCount < k) {
                        right++;
                        replacementCharacterCount++;
                    }
                    else {
                        
                        // The current window has replacementCharacterCount more than 'K', then we need to shorten the window, therefore move left pointer ahead. While doing this check whether the character excluded is the matching character or not. Accordingly, update the replacementCharacterCount
                        if (s.charAt(left) == ch) {
                            left++;
                        }
                        else {
                            left++;
                            replacementCharacterCount--;
                        }
                    }
                }
                
                // Find the maximum valid string length as the window will always be valid
                ans = Math.max(ans, right - left);
            }
        }
        
        return ans;
    }
}



Time Complexity: O(N), where N is the length of the array
Space Complexity: O(26), where N is the length of the array


APPROACH 2
// Here, greedy approach is also being applied. If we have found a valid window, then we will try to find a window bigger than that, therefore discarding the smaller windows. Because we require longest window
class Solution {
    public int characterReplacement(String s, int k) {
        
        int n = s.length();
        
        // Stores the frequency of each character in the current window
        int[] count = new int[26];
        Arrays.fill(count, 0);
        
        // maximum frequency of a character in a window where the window was once valid
        int maxFrequencyLength = 0;        
        
        int ans = 0;
        int left = 0, right = 0;
        while(right < n) {
            
            // Update the frequency of character
            count[s.charAt(right) - 'A']++;
            
            // Update max frquency of character in the current window. It will be updated if the current window is valid. (It happens logically)
            maxFrequencyLength = Math.max(maxFrequencyLength, count[s.charAt(right) - 'A']);
            
            // check whether the window is valid or not. If not valid, then shrink the window
            int windowSize = right - left + 1;
            if ((windowSize - maxFrequencyLength) > k) {
                // Number of replacements are more than K
                
                // Decrementing the frequency of character as string is shrinking from left
                count[s.charAt(left) - 'A']--;               
                left++;
            }
            
            // Update the maximum window. The value will only be updated when there will be a valid window
            ans = Math.max(ans, (right - left + 1));
            right++;
        }
        
        return ans;
    }
}

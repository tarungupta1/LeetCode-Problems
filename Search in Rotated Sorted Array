Problem Number: 33
Problem Name: Search in Rotated Sorted Array
Link: https://leetcode.com/problems/search-in-rotated-sorted-array/

Question
There is an integer array nums sorted in ascending order (with distinct values).
Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].
Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.
You must write an algorithm with O(log n) runtime complexity.
 
           
            
Solution 


Time Complexity: O(log(N)), where N is the length of the array
Space Complexity: O(1)


APPROACH 1
class Solution {
    public int search(int[] nums, int target) {
        
        // determine the index of minimum element
        int low = 0;    // low is index where smallest element will lie
        int high = nums.length - 1;
        while(low < high) {
            int mid = (low + ((high - low) / 2));
            
            if (nums[mid] <= nums[high]) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
    
        
        // Given array can be split into 1 or 2 parts each being sorted. 
        // A-> If 1 part possible, then array to search will be from [0 to (n-1)]
        // B-> If 2 parts possible, then array to search will be can be from [0 to (low-1)] or [low to (n-1)]
        // Determining which areray to search the target
        int first, last;
        
        // If target is smaller than first element, then search in the second array
        if (target < nums[0]) {
            first = low;
            last = nums.length - 1;
        }
        // else search in the first array
        else {
            first = 0;
            last = (low - 1 + nums.length) % nums.length;   // to determine higher_bound
        }
        
        
        // searching the target in the array
        while(first <= last){
            int mid = (last + first)/2;

            if(nums[mid] == target){
                return mid;
            }
            else if(target < nums[mid]) {
                last = mid - 1;
            }
            else {
                first = mid + 1;
            }
        }
        
        return -1;
    }
}



Time Complexity: O(log(N)), where N is the length of the array
Space Complexity: O(1)


APPROACH 2
// Idea: To determine with certainty which half of the array to look in, even though the array is rotated. By checking which half of the array is sorted and then using the sorted property to determine if the target lies in that half or not
class Solution {
    public int search(int[] nums, int target) {
        
        int low = 0;    
        int high = nums.length - 1;
        while(low <= high) {
            int mid = (low + ((high - low) / 2));
            
            if (nums[mid] == target) {
                return mid;
            }
            
            // If first half is sorted, then checking whether the target is part of first half or not. If it is, then picking first half to search else picking second half
            if (nums[low] <= nums[mid]) {
                if (nums[low] <= target && target < nums[mid]) {
                    high = mid - 1;
                }
                else {
                    low = mid + 1;
                }
            }
            // If second half is sorted, then checking whether the target is part of second half or not. If it is, then picking second half to search else picking first half

            else {
                if (nums[mid] < target && target <= nums[high]) {
                    low = mid + 1;
                }
                else {
                    high = mid - 1;
                }
            }
        }
           
        return -1;
    }
}
